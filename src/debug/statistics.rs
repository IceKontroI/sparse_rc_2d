use std::ops::*;
use bevy::{image::*, prelude::*, render::{gpu_readback::*, render_resource::*}};
use gputil::attach::*;
use num_format::*;
use crate::debug::metrics::*;
use crate::core::constants::*;
use crate::gpu_resources::{textures::*, uniforms::*};

#[derive(Default, Copy, Clone, ShaderType)]
pub struct Statistics {
    pub merge_count: u32,
    pub data_lost: u32,
    pub c0_tasks: u32,
    pub ray_hits: u32,
    pub slabs_allocated: u32,
    pub rays_per_level: [u32; MAX_CASCADES],
    pub threads_active: u32,
    pub threads_idle: u32,
    pub debug_ray_count: u32,
}

pub fn readback(
    trigger: On<ReadbackComplete>,
    rcu: Res<RcUniforms>,
    mut merge_count: Metrics<MergeCount>,
    mut rays_cast: Metrics<RaysCast<MAX_CASCADES>>,
    mut ray_hits: Metrics<RayHits>,
    mut c0_tasks: Metrics<C0Tasks>,
    mut dense_memory: Metrics<DenseMemory>,
    mut sparse_memory: Metrics<SparseMemory>,
    mut thread_utilization: Metrics<ThreadUtilization>,
    mut data_lost: Metrics<SlabAllocFailures>,
    mut debug_rays: Metrics<DebugRays>,
) {
    let statistics = trigger.event().to_shader_type::<Statistics>();
    merge_count += statistics.merge_count as usize;
    data_lost += statistics.data_lost;
    c0_tasks += statistics.c0_tasks;
    ray_hits += statistics.ray_hits;
    if rcu.rc_model == 2 {
        // dense model scales with cascade size (quarter-res)
        dense_memory += (rcu.cascade_dims.x * rcu.cascade_dims.y) as usize;
    } else {
        // sparse model scales with slab allocation
        sparse_memory += statistics.slabs_allocated;
    }
    let active = statistics.threads_active as f32;
    let total = (statistics.threads_active + statistics.threads_idle) as f32;
    thread_utilization += active / total;
    rays_cast += RayArray(statistics.rays_per_level);
    debug_rays += statistics.debug_ray_count as usize;
}

/// Number of times the merge process was performed.
pub struct MergeCount;
impl Metric for MergeCount {
    type Data = usize;

    fn emit(count: usize, frames: u32) {
        if count > 0 && frames > 0 {
            let merges = (count / frames as usize).to_formatted_string(&Locale::en);
            info!("Merges: {merges}");
        }
    }
}

/// Amount of times a workgroup needed a slab but the slab pool was empty.
/// Only tracks frequency and not shortfall since slab allocation is an exit criteria.
pub struct SlabAllocFailures;
impl Metric for SlabAllocFailures {
    type Data = u32;

    fn emit(count: u32, frames: u32) {
        if count > 0 && frames > 0 {
            let lost = (count / frames).to_formatted_string(&Locale::en);
            warn!("Slab allocation failures: {lost}");
        }
    }
}

/// Number of c0 "seed" tasks generated by the sparse model.
pub struct C0Tasks;
impl Metric for C0Tasks {
    type Data = u32;

    fn emit(count: u32, frames: u32) {
        if count > 0 && frames > 0 {
            let c0_tasks = (count / frames).to_formatted_string(&Locale::en);
            info!("c0 seed tasks: {c0_tasks}");
        }
    }
}

/// Number of times a ray hit a solid in the scene and was occluded, preventing it from merging.
pub struct RayHits;
impl Metric for RayHits {
    type Data = u32;

    fn emit(count: u32, frames: u32) {
        if count > 0 && frames > 0 {
            let ray_hits = (count / frames).to_formatted_string(&Locale::en);
            info!("Ray hits: {ray_hits}");
        }
    }
}

/// Emits memory metrics for the scene when SparseEdge or SparseFilled models are active.
/// 
/// Ignores some texture resources which will not generalize to 3D, or that 3D apps should solve in a context-sensitive way:
/// * JFA textures (2x full-res images)
/// * Distance field (1x full-res image)
/// * Scene albedo/emissive (2x full-res images)
/// 
/// The Sparse model also uses a quarter-res image to store lighting data before immediately copying it to the scene:
/// * This is ignored since we could just write directly to the scene, but that would only work in 2D.
/// * It also makes the business logic clearer because the Sparse and Dense models now both composite lighting the same way.
pub struct SparseMemory;
impl Metric for SparseMemory {
    type Data = u32;

    fn emit(slabs: u32, frames: u32) {
        if slabs > 0 && frames > 0 {

            let slabs = slabs as f32 / frames as f32;
            let slab_str = (slabs as u32).to_formatted_string(&Locale::en);
            let total_slabs = SLAB_CAPACITY.to_formatted_string(&Locale::en);

            let mbs = (BYTES_PER_SLAB as f32 * slabs) / 1000000.0;
            let total_mbs = (BYTES_PER_SLAB * SLAB_CAPACITY) as f32 / 1000000.0;

            info!("[Sparse] Slabs allocated: {slab_str}/{total_slabs} slabs");
            info!("[Sparse] Memory required: {mbs:.2}/{total_mbs:2} MB");
        }
    }
}

/// Memory metrics for the scene when Dense model is active.
/// 
/// Ignores some texture resources which will not generalize to 3D, or that 3D apps should solve in a context-sensitive way:
/// * JFA textures (2x full-res images)
/// * Distance field (1x full-res image)
/// * Scene albedo/emissive (2x full-res images)
/// 
/// All cascade-related textures are upscaled slightly to be power of 2 (up until the highest cascade level).
/// This ensures that all cascade blocks fit comfortably within the texture bounds, but adds memory overhead.
pub struct DenseMemory;
impl Metric for DenseMemory {
    type Data = usize;

    fn emit(cascade_texels: usize, frames: u32) {
        if cascade_texels > 0 && frames > 0 {
            // average resolution over frame period
            let cascade_texels = cascade_texels / frames as usize;
            // cost of 1 texel in both A and B combined
            let texel_bytes = DirectLightingA::TEXTURE_FORMAT.pixel_size() + DirectLightingB::TEXTURE_FORMAT.pixel_size();
            // total MB over both textures
            let total_texture_bits = texel_bytes * cascade_texels;
            let mb = total_texture_bits as f32 / 1_000_000.0;
            info!("[Dense] Memory used: {mb:.3} MB");
        }
    }
}

#[derive(Default, Debug, Copy, Clone, Deref, DerefMut)]
pub struct RayArray<const LEN: usize>([u32; LEN]) 
    where [u32; LEN]: Default;

impl<const LEN: usize> AddAssign for RayArray<LEN>
    where [u32; LEN]: Default
{
    fn add_assign(&mut self, rhs: Self) {
        for i in 0..LEN {
            self[i] += rhs[i];
        }
    }
}

/// Overall number of rays cast to render lighting for the scene.
/// Also shows per-cascade level metrics for number of rays cast.
pub struct RaysCast<const LEN: usize>;
impl<const LEN: usize> Metric for RaysCast<LEN> 
    where [u32; LEN]: Default
{
    type Data = RayArray<LEN>;

    fn emit(count: RayArray<LEN>, frames: u32) {
        if frames > 0 {
            let mut total_rays: usize = 0;
            let mut cascade_debug = String::new();
            for i in 0..LEN {
                match count[i] {
                    0 => break,
                    cascade_rays => {
                        if cascade_debug.len() > 0 {
                            cascade_debug += ", ";
                        }
                        let cascade_rays_string = (cascade_rays / frames).to_formatted_string(&Locale::en);
                        cascade_debug += &format!("c{i}: {cascade_rays_string}");
                        total_rays += cascade_rays as usize;
                    },
                }
            }
            if total_rays > 0 {
                let total_rays_string = (total_rays / frames as usize).to_formatted_string(&Locale::en);
                info!("Total rays: {total_rays_string}");
                info!("Rays per cascade: [{}]", cascade_debug);
            }
        }
    }
}

/// Percent of non-idle invocations averaged over all iterations of all workgroups.
pub struct ThreadUtilization;
impl Metric for ThreadUtilization {
    type Data = f32;

    fn emit(ratio: f32, frames: u32) {
        if ratio > 0.0 && frames > 0 {
            let ratio = ratio / frames as f32;
            let message = format!("Thread utilization: {:.3}%", ratio * 100.0);
            if ratio > 0.85 {
                info!("{}", message);
            } else {
                warn!("{}", message);
            }
        }
    }
}

/// Number of rays being debugged on screen when in Ray Debug mode.
pub struct DebugRays;
impl Metric for DebugRays {
    type Data = usize;

    fn emit(count: usize, frames: u32) {
        if count > 0 && frames > 0 {
            let count = (count / frames as usize).to_formatted_string(&Locale::en);
            info!("Debug ray count: {count}");
        }
    }
}
